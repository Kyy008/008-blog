---
import ImageWrapper from "../components/misc/ImageWrapper.astro";
import { siteConfig } from "../config";
import localAnimeList from "../data/anime";
import I18nKey from "../i18n/i18nKey";
import { i18n } from "../i18n/translation";
import MainGridLayout from "../layouts/MainGridLayout.astro";
import fs from "node:fs";
import path from "node:path";
import { widgetManager } from "../utils/widget-manager";
import "../styles/anime.css";

interface AnimeItem {
	title: string;
	cover: string;
	link: string;
	description: string;
	year: string;
}

if (!siteConfig.featurePages.anime) {
	return Astro.redirect("/404/");
}

const hasRightSidebars =
	widgetManager.getComponentsByPosition("top", "right", "desktop").length > 0 ||
	widgetManager.getComponentsByPosition("sticky", "right", "desktop").length > 0;
const BANGUMI_USER_ID = siteConfig.bangumi?.userId || "your-user-id";
const BILIBILI_VMID = siteConfig.bilibili?.vmid || "";
const ANIME_MODE = siteConfig.anime?.mode || "bangumi";

let animeList: AnimeItem[] = [];

if (ANIME_MODE === "local") {
	animeList = localAnimeList;
} else if (ANIME_MODE === "bilibili") {
	const isDev = import.meta.env.DEV;
	const shouldFetchOnDev = siteConfig.bilibili?.fetchOnDev ?? false;
	const skipLoad = isDev && !shouldFetchOnDev;

	if (skipLoad) {
		console.log("[Dev] Skipping Bilibili data load (fetchOnDev is off).");
		animeList = [];
	} else {
		try {
			const dataPath = path.join(
				process.cwd(),
				"src/data/bilibili-data.json",
			);
			if (fs.existsSync(dataPath)) {
				const fileContent = fs.readFileSync(dataPath, "utf-8");
				const rawData = JSON.parse(fileContent);
				animeList = rawData.map((item: any) => ({
					title: item.title || "Unknown",
					cover: item.cover || "",
					link: item.link || "",
					status: item.status || "planned",
					rating: Number(item.rating) || 0,
					progress: Number(item.progress) || 0,
					totalEpisodes: Number(item.totalEpisodes) || 12,
					description: item.description || "",
					year: item.year || "",
					studio: item.studio || "",
					genre: Array.isArray(item.genre) ? item.genre : [],
				}));
			} else {
				console.warn(`Bilibili data file not found at ${dataPath}.`);
				animeList = [];
			}
		} catch (error) {
			console.error("Failed to load Bilibili anime data:", error);
			animeList = [];
		}
	}
} else {
	const isDev = import.meta.env.DEV;
	const shouldFetchOnDev = siteConfig.bangumi?.fetchOnDev ?? false;
	const skipLoad = isDev && !shouldFetchOnDev;

	if (skipLoad) {
		console.log("[Dev] Skipping Bangumi data load (fetchOnDev is off).");
		animeList = [];
	} else {
		try {
			const dataPath = path.join(
				process.cwd(),
				"src/data/bangumi-data.json",
			);
			if (fs.existsSync(dataPath)) {
				const fileContent = fs.readFileSync(dataPath, "utf-8");
				const rawData = JSON.parse(fileContent);
				animeList = rawData.map((item: any) => ({
					title: item.title || "Unknown",
					cover: item.cover || "",
					link: item.link || "",
					description: item.description || "",
					year: item.year || "",
				}));
			} else {
				console.warn(`Bangumi data file not found at ${dataPath}.`);
				animeList = [];
			}
		} catch (error) {
			console.error("Failed to load anime data:", error);
			animeList = [];
		}
	}
}

const INITIAL_DISPLAY_COUNT = 24;
const visibleAnimeList = animeList.slice(0, INITIAL_DISPLAY_COUNT);
const hiddenAnimeList = animeList.slice(INITIAL_DISPLAY_COUNT);
---

<MainGridLayout
	title={i18n(I18nKey.anime)}
	description={i18n(I18nKey.animeSubtitle)}
>
	<div
		class="flex w-full rounded-[var(--radius-large)] overflow-hidden relative min-h-32"
	>
		<div class="card-base anime-card-base z-10 px-9 py-6 relative w-full">
			<div class="relative w-full mb-8">
				<div class="mb-6">
					<h1
						class="text-4xl font-bold text-black/90 dark:text-white/90 mb-2 relative
                    before:w-1 before:h-8 before:rounded-md before:bg-[var(--primary)]
                    before:absolute before:top-1/2 before:-translate-y-1/2 before:-left-4"
					>
						{i18n(I18nKey.animeTitle)}
					</h1>
					<p class="text-black/75 dark:text-white/75">
						{i18n(I18nKey.animeSubtitle)}
					</p>
				</div>

				<div class="mb-6">
					<div class="anime-filter-container flex flex-wrap gap-2">
						<button
							class="anime-filter-tag anime-active"
							data-status="all"
							>{i18n(I18nKey.animeFilterAll)}</button
						>
						<button class="anime-filter-tag" data-status="watching"
							>{i18n(I18nKey.animeStatusWatching)}</button
						>
						<button class="anime-filter-tag" data-status="planned"
							>{i18n(I18nKey.animeStatusPlanned)}</button
						>
						<button class="anime-filter-tag" data-status="completed"
							>{i18n(I18nKey.animeStatusCompleted)}</button
						>
						{
							(ANIME_MODE === "bangumi" || ANIME_MODE === "bilibili") && (
								<>
									<button
										class="anime-filter-tag"
										data-status="onhold"
									>
										{i18n(I18nKey.animeStatusOnHold)}
									</button>
									<button
										class="anime-filter-tag"
										data-status="dropped"
									>
										{i18n(I18nKey.animeStatusDropped)}
									</button>
								</>
							)
						}
					</div>
				</div>
			</div>

			<div class="mb-8">
					{
						ANIME_MODE === "bilibili" &&
						(!BILIBILI_VMID || BILIBILI_VMID === "") ? (
							<div class="text-center py-12">
								<div class="text-5xl mb-4">üò¢</div>
								<h3 class="text-xl font-medium text-black/80 dark:text-white/80 mb-2">
									{i18n(I18nKey.animeEmpty)}
								</h3>
								<p class="text-black/60 dark:text-white/60">
									Please set your Bilibili vmid in the
									src/config.ts file
								</p>
							</div>
						) : ANIME_MODE !== "local" &&
							ANIME_MODE !== "bilibili" &&
							BANGUMI_USER_ID === "your-user-id" ? (
						<div class="text-center py-12">
							<div class="text-5xl mb-4">üò¢</div>
							<h3 class="text-xl font-medium text-black/80 dark:text-white/80 mb-2">
								{i18n(I18nKey.animeEmpty)}
							</h3>
							<p class="text-black/60 dark:text-white/60">
								Please set your Bangumi userId in the
								src/config.ts file
							</p>
						</div>
					) : visibleAnimeList.length > 0 ? (
						<>
							<div
								id="anime-list-container"
								class={`anime-grid-container grid gap-4 md:gap-6 opacity-0 transition-opacity duration-300`}
							>
								{visibleAnimeList.map((anime) => {
									return (
										<div
											class="group relative bg-[var(--card-bg)] border border-[var(--line-divider)] rounded-[var(--radius-large)] overflow-hidden hover:shadow-lg"
										>
											<div class="relative anime-cover-container aspect-[2/3] overflow-hidden">
												<a
													href={anime.link}
													target="_blank"
													rel="noopener noreferrer"
													class="block w-full h-full"
												>
													<ImageWrapper
														src={anime.cover}
														alt={anime.title}
														class="w-full h-full object-cover transition-transform duration-200 group-hover:scale-110"
													/>
													<div class="absolute inset-0 bg-gradient-to-t from-black/60 via-transparent to-transparent opacity-0 group-hover:opacity-100 transition-opacity duration-300">
														<div class="absolute inset-0 flex items-center justify-center">
															<div class="w-12 h-12 rounded-full bg-white/90 flex items-center justify-center">
																<svg
																	class="w-6 h-6 text-gray-800 ml-1"
																	fill="currentColor"
																	viewBox="0 0 24 24"
																>
																	<path d="M8 5v14l11-7z" />
																</svg>
															</div>
														</div>
													</div>
												</a>
											</div>

											<div class="p-3">
												<h3 class="text-sm font-bold text-black/90 dark:text-white/90 mb-1 leading-tight">
													{anime.title}
												</h3>
												<p
													class="text-black/60 dark:text-white/60 text-xs mb-2 line-clamp-2"
													title={anime.description}
												>
													{anime.description}
												</p>

												<div class="space-y-1 text-xs">
													<div class="flex justify-between items-center">
														<span class="text-black/50 dark:text-white/50 shrink-0">
															{i18n(
																I18nKey.animeYear,
															)}
														</span>
														<span class="text-black/70 dark:text-white/70 truncate ml-2 text-right">
															{anime.year}
														</span>
													</div>
												</div>
											</div>
										</div>
									);
								})}
							</div>

							<template id="anime-lazy-store">
								{hiddenAnimeList.map((anime) => {
									return (
										<div
											class="group relative bg-[var(--card-bg)] border border-[var(--line-divider)] rounded-[var(--radius-large)] overflow-hidden hover:shadow-lg"
										>
											<div class="relative anime-cover-container aspect-[2/3] overflow-hidden">
												<a
													href={anime.link}
													target="_blank"
													rel="noopener noreferrer"
													class="block w-full h-full"
												>
													<ImageWrapper
														src={anime.cover}
														alt={anime.title}
														class="w-full h-full object-cover transition-transform duration-200 group-hover:scale-110"
													/>
													<div class="absolute inset-0 bg-gradient-to-t from-black/60 via-transparent to-transparent opacity-0 group-hover:opacity-100 transition-opacity duration-300">
														<div class="absolute inset-0 flex items-center justify-center">
															<div class="w-12 h-12 rounded-full bg-white/90 flex items-center justify-center">
																<svg
																	class="w-6 h-6 text-gray-800 ml-1"
																	fill="currentColor"
																	viewBox="0 0 24 24"
																>
																	<path d="M8 5v14l11-7z" />
																</svg>
															</div>
														</div>
													</div>
												</a>
											</div>

											<div class="p-3">
												<h3 class="text-sm font-bold text-black/90 dark:text-white/90 mb-1 leading-tight">
													{anime.title}
												</h3>
												<p
													class="text-black/60 dark:text-white/60 text-xs mb-2 line-clamp-2"
													title={anime.description}
												>
													{anime.description}
												</p>

												<div class="space-y-1 text-xs">
													<div class="flex justify-between items-center">
														<span class="text-black/50 dark:text-white/50 shrink-0">
															{i18n(
																I18nKey.animeYear,
															)}
														</span>
														<span class="text-black/70 dark:text-white/70 truncate ml-2 text-right">
															{anime.year}
														</span>
													</div>
												</div>
											</div>
										</div>
									);
								})}
							</template>

							{hiddenAnimeList.length > 0 && (
								<div
									id="infinite-scroll-sentinel"
									class="w-full h-20 flex items-center justify-center mt-8"
								>
									<div class="anime-loading-spinner w-8 h-8 border-4 border-[var(--primary)] border-t-transparent rounded-full animate-spin" />
								</div>
							)}
						</>
					) : (
						<div class="text-center py-12">
							<div class="text-5xl mb-4">üò¢</div>
							<h3 class="text-xl font-medium text-black/80 dark:text-white/80 mb-2">
								{i18n(I18nKey.animeEmpty)}
							</h3>
							<p class="text-black/60 dark:text-white/60">
								{ANIME_MODE === "local"
									? i18n(I18nKey.animeEmptyLocal)
									: ANIME_MODE === "bilibili"
										? "BilibiliÊï∞ÊçÆ‰∏∫Á©∫ÔºåËØ∑ËøêË°å pnpm run update-bilibili Ëé∑ÂèñÊï∞ÊçÆ"
										: i18n(I18nKey.animeEmptyBangumi)}
							</p>
						</div>
					)
				}
			</div>
		</div>
	</div>

	<script is:inline define:vars={{ hasRightSidebars }}>
		(function () {
			function initAnimeLayout() {
				const animeListContainer = document.getElementById(
					"anime-list-container",
				);
				if (!animeListContainer) return false;
				const currentLayout =
					localStorage.getItem("postListLayout") || "list";
				updateAnimeListLayout(currentLayout, false);
				requestAnimationFrame(() => {
					animeListContainer.classList.remove("opacity-0");
				});
				return true;
			}

			let retryCount = 0;
			const maxRetries = 10;
			function tryInit() {
				if (initAnimeLayout()) return;
				if (retryCount < maxRetries) {
					retryCount++;
					const delay = Math.min(
						100 * Math.pow(1.5, retryCount),
						1000,
					);
					setTimeout(tryInit, delay);
				} else {
					setTimeout(() => {
						const animeListContainer = document.getElementById(
							"anime-list-container",
						);
						if (animeListContainer) {
							const currentLayout =
								localStorage.getItem("postListLayout") ||
								"list";
							updateAnimeListLayout(currentLayout, false);
							animeListContainer.classList.remove("opacity-0");
						}
					}, 2000);
				}
			}

			if (document.readyState === "loading") {
				document.addEventListener("DOMContentLoaded", tryInit);
			} else {
				tryInit();
			}

			function updateAnimeListLayout(layout, shouldAnimate = true) {
				const animeListContainer = document.getElementById(
					"anime-list-container",
				);
				if (!animeListContainer) return;
				animeListContainer.dataset.currentLayout = layout;

				const animeItems = Array.from(
					animeListContainer.children,
				);
				const visibleItems = animeItems.filter(
					(item) => item.offsetParent !== null,
				);
				const firstPositions = new Map();
				if (shouldAnimate) {
					visibleItems.forEach((item) => {
						const rect = item.getBoundingClientRect();
						firstPositions.set(item, {
							left: rect.left,
							top: rect.top,
							width: rect.width,
							height: rect.height,
						});
					});
				}

				const style = document.createElement("style");
				style.innerHTML = `.anime-grid-container .group { transition: none !important; }`;
				document.head.appendChild(style);
				animeListContainer.classList.remove(
					"anime-list-mode",
					"anime-grid-mode",
				);
				animeListContainer.classList.remove(
					"grid-cols-1",
					"md:grid-cols-2",
					"lg:grid-cols-3",
				);

				if (layout === "grid") {
					animeListContainer.classList.add("anime-grid-mode");
					const rightSidebar = document.querySelector(
						".right-sidebar-container",
					);
					if (rightSidebar) {
						rightSidebar.style.display = "none";
						rightSidebar.classList.add("hidden-in-grid-mode");
					}
					const mainGrid = document.getElementById("main-grid");
					if (mainGrid) {
						mainGrid.style.gridTemplateColumns = "17.5rem 1fr";
						mainGrid.classList.add("two-column-layout");
					}
				} else {
					animeListContainer.classList.add("anime-list-mode");
					animeListContainer.classList.add(
						"grid-cols-1",
						"lg:grid-cols-2",
					);
					const rightSidebar = document.querySelector(
						".right-sidebar-container",
					);
					if (rightSidebar) {
						rightSidebar.style.display = "";
						rightSidebar.classList.remove("hidden-in-grid-mode");
					}
					const mainGrid = document.getElementById("main-grid");
					if (mainGrid) {
						mainGrid.style.gridTemplateColumns = "";
						mainGrid.classList.remove("two-column-layout");
					}
				}

				void animeListContainer.offsetHeight;
				if (!shouldAnimate) {
					if (style.parentNode) style.parentNode.removeChild(style);
					return;
				}

				requestAnimationFrame(() => {
					if (style.parentNode) style.parentNode.removeChild(style);

					visibleItems.forEach((item) => {
						const first = firstPositions.get(item);
						if (!first) return;
						const last = item.getBoundingClientRect();

						const deltaX = Math.round(first.left - last.left);
						const deltaY = Math.round(first.top - last.top);
						const deltaW = first.width / last.width;
						const deltaH = first.height / last.height;

						if (
							Math.abs(deltaX) < 1 &&
							Math.abs(deltaY) < 1 &&
							Math.abs(deltaW - 1) < 0.01 &&
							Math.abs(deltaH - 1) < 0.01
						)
							return;

						item.style.willChange = "transform";
						item.style.transition = "none";
						item.style.transformOrigin = "top left";
						item.style.transform = `translate(${deltaX}px, ${deltaY}px) scale(${deltaW}, ${deltaH})`;
					});

					void animeListContainer.offsetHeight;
					requestAnimationFrame(() => {
						visibleItems.forEach((item) => {
							item.style.transition =
								"transform 0.5s cubic-bezier(0.25, 0.8, 0.25, 1)";
							item.style.transform = "";
						});
						setTimeout(() => {
							visibleItems.forEach((item) => {
								item.style.transition = "";
								item.style.transformOrigin = "";
								item.style.transform = "";
								item.style.willChange = "";
							});
						}, 500);
					});
				});
			}

			window.addEventListener("layoutChange", (event) => {
				updateAnimeListLayout(event.detail.layout);
			});
		})();
	</script>

	<script is:inline>
		function initInfiniteScroll() {
			const sentinel = document.getElementById(
				"infinite-scroll-sentinel",
			);
			const listContainer = document.getElementById(
				"anime-list-container",
			);
			const lazyStore = document.getElementById("anime-lazy-store");

			if (sentinel && lazyStore && listContainer) {
				const observer = new IntersectionObserver(
					(entries) => {
						if (entries[0].isIntersecting) {
							const BATCH_SIZE = 24;
							if (lazyStore.content.children.length === 0) {
								sentinel.style.display = "none";
								observer.disconnect();
								return;
							}

							const fragment = document.createDocumentFragment();
							let movedCount = 0;
							while (
								lazyStore.content.firstChild &&
								movedCount < BATCH_SIZE
							) {
								const node = lazyStore.content.firstChild;
								if (node.nodeType === 1) {
									node.classList.add("anime-fade-in-active");
								}
								fragment.appendChild(node);
								movedCount++;
							}

							requestAnimationFrame(() => {
								listContainer.appendChild(fragment);
								if (lazyStore.content.children.length === 0) {
									sentinel.style.display = "none";
									observer.disconnect();
								}
							});
						}
					},
					{ rootMargin: "200px" },
				);
				observer.observe(sentinel);
			} else if (sentinel) {
				sentinel.style.display = "none";
			}
		}

		document.addEventListener("DOMContentLoaded", initInfiniteScroll);
		function setupSwupListeners() {
			if (window.swup) {
				window.swup.hooks.on("content:replace", () =>
					setTimeout(initInfiniteScroll, 150),
				);
				window.swup.hooks.on("page:view", () =>
					setTimeout(initInfiniteScroll, 150),
				);
			}
		}

		if (typeof window !== "undefined") {
			if (window.swup) {
				setupSwupListeners();
			} else {
				document.addEventListener("swup:enable", setupSwupListeners);
			}
		}
	</script>
</MainGridLayout>
